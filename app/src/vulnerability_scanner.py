#!/usr/bin/env python3

"""
Vulnerability Scanner using Nuclei
Focused vulnerability assessment for Nmap-scanned targets with CVE and misconfig tags
"""

import subprocess
import json
import os
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
from pymongo import MongoClient
from pymongo.errors import ServerSelectionTimeoutError, OperationFailure

# Import configuration
from config import MONGO_URI, RESULTS_DIR, SCAN_TIMEOUT, RATE_LIMIT, LOG_LEVEL

# Configure logging based on config
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/vulnerability_scanner.log'),
        logging.StreamHandler()
    ]
)

def safe_dumps(obj: Any) -> str:
    """
    JSON dump that won't crash on ObjectId, datetime, etc.
    Falls back to str() for unknown types.
    """
    return json.dumps(obj, indent=2, default=str)

class VulnerabilityScanner:
    def __init__(self):
        self.nuclei_path = "nuclei"
        self.results_dir = RESULTS_DIR
        os.makedirs(self.results_dir, exist_ok=True)
        
        # MongoDB connection using config
        try:
            self.mongo_client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
            self.mongo_client.server_info()  # Test connection
            logging.info("MongoDB connection established")
        except ServerSelectionTimeoutError as e:
            logging.error(f"Failed to connect to MongoDB: {e}")
            raise
        
        self.nuclei_vuln_collection = self.mongo_client["scan_results"]["nuclei_vuln"]
        
        # Load target list from ip.txt - FIXED PATH
        self.target_list = self._load_target_list()
        logging.info(f"Initialized VulnerabilityScanner with {len(self.target_list)} targets")

    def __del__(self):
        """Cleanup MongoDB client on object deletion (safe at interpreter shutdown)."""
        try:
            if hasattr(self, 'mongo_client'):
                self.mongo_client.close()
                logging.info("MongoDB client closed")
        except Exception:
            pass

    def _load_target_list(self) -> List[str]:
        """Load target IPs from ip.txt in the correct location."""
        target_list = []
        
        # Get the correct path to ip.txt (project root, not src folder)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(script_dir) if os.path.basename(script_dir) == 'src' else script_dir
        project_root = os.path.dirname(project_root)  # Go up one more level to main project folder
        ip_file_path = os.path.join(project_root, "ip.txt")
        
        logging.info(f"Looking for target list at: {ip_file_path}")
        
        try:
            if os.path.exists(ip_file_path):
                with open(ip_file_path, "r") as f:
                    target_list = [line.strip() for line in f if line.strip()]
                logging.info(f"âœ… Loaded {len(target_list)} targets from {ip_file_path}: {target_list}")
            else:
                logging.warning(f"âš ï¸  ip.txt not found at {ip_file_path}")
                # Try alternative locations
                alt_paths = [
                    os.path.join(script_dir, "ip.txt"),  # src/ip.txt
                    os.path.join(os.path.dirname(script_dir), "ip.txt"),  # app/ip.txt
                    "ip.txt"  # current directory
                ]
                
                for alt_path in alt_paths:
                    if os.path.exists(alt_path):
                        logging.info(f"ðŸ“ Found ip.txt at alternative location: {alt_path}")
                        with open(alt_path, "r") as f:
                            target_list = [line.strip() for line in f if line.strip()]
                        logging.info(f"âœ… Loaded {len(target_list)} targets from {alt_path}: {target_list}")
                        break
                        
                if not target_list:
                    logging.error(f"âŒ No ip.txt file found in any of these locations:")
                    for path in [ip_file_path] + alt_paths:
                        logging.error(f"   - {path}")
                        
        except Exception as e:
            logging.error(f"âŒ Error loading target list: {e}")
            
        return target_list

    def run_nuclei_scan_with_tags(self, target: str) -> Dict[str, Any]:
        """
        Run Nuclei vulnerability scan with tags cves,misconfig and no proxy.
        Uses format: nuclei -u target -tags cves,misconfig -proxy ""
        Processes output like [weak-cipher-suites:tls-1.0] [ssl] [low] google.com:443 [...]

        Args:
            target: IP address or URL to scan

        Returns:
            Dictionary containing scan results
        """
        logging.info(f"Starting tagged vulnerability scan for target: {target}")
        
        # Refresh target list to get latest targets
        self.target_list = self._load_target_list()
        
        if target not in self.target_list:
            logging.warning(f"Target {target} not in ip.txt target list, skipping.")
            logging.info(f"Available targets: {self.target_list}")
            return {"error": "Target not in authorized list", "target": target}

        try:
            # Fetch the latest Nmap scan to confirm target was scanned
            nmap_collection = self.mongo_client["scan_results"]["nmap_scans"]
            latest_nmap_scan = nmap_collection.find_one({"server_ip": target}, sort=[("scanned_date", -1)])
            
            if not latest_nmap_scan:
                logging.error(f"No Nmap scan data found for {target}")
                return {"error": "No Nmap scan data found", "target": target}

            # Prepare Nuclei command with JSONL output
            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            output_file = f"{self.results_dir}/nuclei_tags_{target.replace('.', '_')}_{timestamp}.jsonl"
            
            cmd = [
                self.nuclei_path,
                "-u", target,
                "-tags", "cves,misconfig",
                "-proxy", "",
                "-jsonl",  # JSON Lines output format
                "-o", output_file,
                "-silent",
                "-timeout", str(SCAN_TIMEOUT),
                "-rate-limit", str(RATE_LIMIT)
            ]

            logging.debug(f"Executing Nuclei command: {' '.join(cmd)}")

            # Run Nuclei scan
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=SCAN_TIMEOUT  # Use config timeout
            )

            # Parse results from file or stdout
            vulnerabilities: List[Dict[str, Any]] = []
            
            if os.path.exists(output_file):
                with open(output_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        if line.strip():
                            try:
                                vuln = json.loads(line.strip())
                                vulnerabilities.append(vuln)
                            except json.JSONDecodeError as e:
                                # Handle non-JSON output like [weak-cipher-suites:tls-1.0] [ssl] [low] google.com:443 [...]
                                parts = line.strip().split("] [")
                                if len(parts) >= 4:
                                    template_id, protocol, severity, target_port, details = [p.strip('[]') for p in parts]
                                    vuln_data = {
                                        "template_id": template_id,
                                        "protocol": protocol,
                                        "severity": severity,
                                        "target": target_port.split(":")[0],
                                        "port": target_port.split(":")[1] if ":" in target_port else "unknown",
                                        "details": details.strip('[]"'),
                                        "raw_output": line.strip(),
                                        "timestamp": timestamp
                                    }
                                    vulnerabilities.append(vuln_data)
                                else:
                                    logging.warning(f"Failed to parse line: {line.strip()}, Error: {e}")
                                    vulnerabilities.append({
                                        "raw_output": line.strip(),
                                        "target": target,
                                        "parse_error": str(e)
                                    })
                
                # Clean up temporary file
                try:
                    os.remove(output_file)
                except:
                    pass

            elif result.stdout:
                for line in result.stdout.split('\n'):
                    if line.strip():
                        try:
                            vuln = json.loads(line.strip())
                            vulnerabilities.append(vuln)
                        except json.JSONDecodeError as e:
                            parts = line.strip().split("] [")
                            if len(parts) >= 4:
                                template_id, protocol, severity, target_port, details = [p.strip('[]') for p in parts]
                                vuln_data = {
                                    "template_id": template_id,
                                    "protocol": protocol,
                                    "severity": severity,
                                    "target": target_port.split(":")[0],
                                    "port": target_port.split(":")[1] if ":" in target_port else "unknown",
                                    "details": details.strip('[]"'),
                                    "raw_output": line.strip(),
                                    "timestamp": timestamp
                                }
                                vulnerabilities.append(vuln_data)
                            else:
                                logging.warning(f"Failed to parse stdout line: {line.strip()}, Error: {e}")
                                vulnerabilities.append({
                                    "raw_output": line.strip(),
                                    "target": target,
                                    "parse_error": str(e)
                                })
            else:
                logging.warning(f"No output file or stdout for {target}. Stderr: {result.stderr}")

            # Generate summary
            summary = self._generate_summary(vulnerabilities, target)

            # Store in MongoDB nuclei_vuln collection
            vuln_result = {
                "target": target,
                "scan_type": "tagged-cve-misconfig",
                "timestamp": timestamp,
                "vulnerabilities": vulnerabilities,
                "summary": summary,
                "total_vulns": len(vulnerabilities),
                "nmap_scan_id": str(latest_nmap_scan.get("_id", "")),
                "command_executed": " ".join(cmd)
            }

            try:
                self.nuclei_vuln_collection.insert_one(vuln_result)
                logging.info(f"Tagged vulnerability scan results stored for {target}")
            except OperationFailure as e:
                logging.error(f"Failed to insert scan results into MongoDB: {e}")
                return {"error": f"Database insertion failed: {e}", "target": target}

            return vuln_result

        except subprocess.TimeoutExpired:
            logging.error(f"Nuclei tagged scan timeout for {target}")
            return {"error": "Scan timeout", "target": target}
        except FileNotFoundError:
            logging.error(f"Nuclei executable not found at {self.nuclei_path}")
            return {"error": "Nuclei not found, please install or check PATH", "target": target}
        except Exception as e:
            logging.error(f"Unexpected error running Nuclei tagged scan on {target}: {str(e)}")
            return {"error": str(e), "target": target}

    def _generate_summary(self, vulnerabilities: List[Dict], target: str) -> Dict[str, Any]:
        """Generate summary of vulnerabilities"""
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        template_counts: Dict[str, int] = {}
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "info").lower()
            template = vuln.get("template_id", "unknown")
            
            if severity in severity_counts:
                severity_counts[severity] += 1
            
            template_counts[template] = template_counts.get(template, 0) + 1

        return {
            "target": target,
            "total_vulnerabilities": len(vulnerabilities),
            "severity_breakdown": severity_counts,
            "top_templates": dict(sorted(template_counts.items(), key=lambda x: x[1], reverse=True)[:10]),
            "risk_score": self._calculate_risk_score(severity_counts)
        }

    def _calculate_risk_score(self, severity_counts: Dict[str, int]) -> int:
        """Calculate overall risk score based on severity counts"""
        weights = {"critical": 25, "high": 15, "medium": 10, "low": 5, "info": 1}
        total_score = sum(severity_counts[severity] * weights.get(severity, 0) for severity in severity_counts)
        max_possible_score = sum(weights.values()) * 100
        risk_score = min((total_score / max_possible_score) * 100, 100)
        return int(risk_score)

    def scan_all_targets(self) -> List[Dict[str, Any]]:
        """Scan all targets from ip.txt that have Nmap data."""
        results = []
        nmap_collection = self.mongo_client["scan_results"]["nmap_scans"]
        scanned_targets = nmap_collection.distinct("server_ip")
        
        for target in self.target_list:
            if target in scanned_targets:
                result = self.run_nuclei_scan_with_tags(target)
                results.append(result)
            else:
                logging.warning(f"Target {target} not found in Nmap scans, skipping.")
        
        return results

    def run_vulnerability_scan(self, target: str) -> Dict[str, Any]:
        """
        Run a vulnerability scan for a specific target, compatible with web interface.
        Delegates to run_nuclei_scan_with_tags for the tagged scan.
        """
        return self.run_nuclei_scan_with_tags(target)

# Global scanner instance
vuln_scanner = VulnerabilityScanner()

# Example usage
if __name__ == "__main__":
    # Run scan for all targets
    scan_results = vuln_scanner.scan_all_targets()
    for result in scan_results:
        print(f"Scan result for {result.get('target', 'Unknown')}:")
        print(safe_dumps(result))
